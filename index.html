<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Cubes and Plats</title>
  <style>
    body {
      background: #222;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
      margin: 0;
      color: #fff;
      font-family: sans-serif;
    }
    canvas {
      image-rendering: pixelated;
      border: 2px solid #fff;
    }
  </style>
</head>
<body>
  <canvas id="game" width="400" height="400"></canvas>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    // Player physics (30x30 cube, “normal” gravity and jump)
    const GRAVITY = 0.5;
    const MOVE_SPEED = 3;
    const JUMP_STRENGTH = -11;
    const FRICTION = 0.8;

    const player = {
      x: 20,
      y: 20,
      w: 30,
      h: 30,
      vx: 0,
      vy: 0,
      onGround: false
    };

    // Game state
    let gameState = "menu"; // "menu", "level1", "level2", "win"
    let selectedLevelIndex = 0;
    let unlockedLevels = 1; // 1 or 2
    let winTimer = 0;
    let lastWonLevel = null;

    // Level 1: Basic Platforms
    const level1 = {
      spawnX: 20,
      spawnY: 340,
      platforms: [
        { x: 0,   y: 370, w: 400, h: 30, color: "#555" },          // floor
        { x: 40,  y: 310, w: 80,  h: 10, color: "#555" },
        { x: 150, y: 270, w: 80,  h: 10, color: "#555" },
        { x: 260, y: 230, w: 80,  h: 10, color: "#00f", goal: true } // blue goal
      ],
      spikes: [] // none for level 1
    };

    // Level 2: Platforms and Spikes (spikes ON platforms)
    const level2 = {
      spawnX: 20,
      spawnY: 340,
      platforms: [
        { x: 0,   y: 370, w: 400, h: 30, color: "#555" },           // floor
        { x: 60,  y: 320, w: 100, h: 10, color: "#555" },           // platform 1
        { x: 210, y: 290, w: 90,  h: 10, color: "#555" },           // platform 2
        { x: 120, y: 240, w: 80,  h: 10, color: "#555" },           // platform 3
        { x: 260, y: 210, w: 90,  h: 10, color: "#00f", goal: true } // blue goal
      ],
      // Spikes sit on top of some platforms (triangles drawn visually, but box used for collision)
      spikes: [
        // On platform 1
        { x: 90,  y: 290, w: 20, h: 30 }, // centered spike
        // On platform 2
        { x: 230, y: 260, w: 20, h: 30 },
        // On platform 3
        { x: 140, y: 210, w: 20, h: 30 }
      ]
    };

    let currentLevel = level1;

    // Input
    const keys = {};
    document.addEventListener("keydown", e => {
      keys[e.code] = true;
    });
    document.addEventListener("keyup", e => {
      keys[e.code] = false;
    });

    function rectIntersect(a, b) {
      return (
        a.x < b.x + b.w &&
        a.x + a.w > b.x &&
        a.y < b.y + b.h &&
        a.y + a.h > b.y
      );
    }

    function setLevel(levelNumber) {
      currentLevel = levelNumber === 1 ? level1 : level2;
      player.x = currentLevel.spawnX;
      player.y = currentLevel.spawnY;
      player.vx = 0;
      player.vy = 0;
      player.onGround = false;
    }

    function updateMenu() {
      // Move selection up/down
      if (keys["ArrowUp"] || keys["KeyW"]) {
        selectedLevelIndex = 0;
      }
      if (keys["ArrowDown"] || keys["KeyS"]) {
        selectedLevelIndex = 1;
      }

      // Clamp by unlocked levels
      if (selectedLevelIndex >= unlockedLevels) {
        selectedLevelIndex = unlockedLevels - 1;
      }
      if (selectedLevelIndex < 0) selectedLevelIndex = 0;

      // Enter to start selected level (if unlocked)
      if (keys["Enter"] || keys["Space"]) {
        if (selectedLevelIndex === 0) {
          setLevel(1);
          gameState = "level1";
        } else if (selectedLevelIndex === 1 && unlockedLevels >= 2) {
          setLevel(2);
          gameState = "level2";
        }
        // prevent immediate re-trigger
        keys["Enter"] = false;
        keys["Space"] = false;
      }
    }

    function updateLevel() {
      // Return to menu with Escape
      if (keys["Escape"]) {
        gameState = "menu";
        keys["Escape"] = false;
        return;
      }

      // Horizontal input
      if (keys["ArrowLeft"] || keys["KeyA"]) {
        player.vx = -MOVE_SPEED;
      } else if (keys["ArrowRight"] || keys["KeyD"]) {
        player.vx = MOVE_SPEED;
      } else {
        player.vx *= FRICTION;
        if (Math.abs(player.vx) < 0.05) player.vx = 0;
      }

      // Jump
      if ((keys["Space"] || keys["ArrowUp"] || keys["KeyW"]) && player.onGround) {
        player.vy = JUMP_STRENGTH;
        player.onGround = false;
      }

      // Gravity
      player.vy += GRAVITY;

      // Horizontal movement + platform collision
      player.x += player.vx;
      for (const p of currentLevel.platforms) {
        const platRect = { x: p.x, y: p.y, w: p.w, h: p.h };
        if (rectIntersect(player, platRect)) {
          if (player.vx > 0) {
            player.x = p.x - player.w;
          } else if (player.vx < 0) {
            player.x = p.x + p.w;
          }
          player.vx = 0;
        }
      }

      // Vertical movement + platform collision
      player.y += player.vy;
      player.onGround = false;
      let landedOnGoal = false;

      for (const p of currentLevel.platforms) {
        const platRect = { x: p.x, y: p.y, w: p.w, h: p.h };
        if (rectIntersect(player, platRect)) {
          if (player.vy > 0) { // falling down
            player.y = p.y - player.h;
            player.vy = 0;
            player.onGround = true;
            if (p.goal) landedOnGoal = true;
          } else if (player.vy < 0) { // hitting from below
            player.y = p.y + p.h;
            player.vy = 0;
          }
        }
      }

      // Spikes collision
      for (const s of currentLevel.spikes) {
        const spikeRect = { x: s.x, y: s.y, w: s.w, h: s.h };
        if (rectIntersect(player, spikeRect)) {
          // reset to spawn for this level
          player.x = currentLevel.spawnX;
          player.y = currentLevel.spawnY;
          player.vx = 0;
          player.vy = 0;
          player.onGround = false;
        }
      }

      // Keep player inside canvas
      if (player.x < 0) player.x = 0;
      if (player.x + player.w > canvas.width) player.x = canvas.width - player.w;

      // If fall off, reset level
      if (player.y > canvas.height + 50) {
        player.x = currentLevel.spawnX;
        player.y = currentLevel.spawnY;
        player.vx = 0;
        player.vy = 0;
        player.onGround = false;
      }

      // Win if landed on the blue goal platform
      if (landedOnGoal) {
        gameState = "win";
        winTimer = performance.now() + 2000;
        lastWonLevel = (currentLevel === level1) ? 1 : 2;

        if (lastWonLevel === 1 && unlockedLevels < 2) {
          unlockedLevels = 2; // unlock level 2
        }
      }
    }

    function updateWin(now) {
      // After 2 seconds, go back to menu
      if (now >= winTimer) {
        gameState = "menu";
      }
    }

    function drawMenu() {
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";

      ctx.font = "24px sans-serif";
      ctx.fillText("Cubes and Plats", canvas.width / 2, 80);

      ctx.font = "16px sans-serif";
      ctx.fillText("Use W/S or Up/Down, Enter/Space to select", canvas.width / 2, 110);

      const levels = [
        { name: "Basic Platforms", unlocked: true },
        { name: "Platforms and Spikes", unlocked: unlockedLevels >= 2 }
      ];

      levels.forEach((level, index) => {
        const y = 160 + index * 40;
        let text = level.name;
        if (!level.unlocked) text += " (locked)";

        if (index === selectedLevelIndex) {
          ctx.fillStyle = "#0f0";
        } else {
          ctx.fillStyle = "#ccc";
        }

        ctx.fillText(text, canvas.width / 2, y);
      });
    }

    function drawLevel() {
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Platforms
      for (const p of currentLevel.platforms) {
        ctx.fillStyle = p.color || "#555";
        ctx.fillRect(p.x, p.y, p.w, p.h);
      }

      // Spikes as red triangles
      for (const s of currentLevel.spikes) {
        ctx.fillStyle = "#f00";
        ctx.beginPath();
        ctx.moveTo(s.x, s.y + s.h);           // left bottom
        ctx.lineTo(s.x + s.w / 2, s.y);       // top
        ctx.lineTo(s.x + s.w, s.y + s.h);     // right bottom
        ctx.closePath();
        ctx.fill();
      }

      // Player cube
      ctx.fillStyle = "#0f0";
      ctx.fillRect(player.x, player.y, player.w, player.h);
    }

    function drawWin() {
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = "#0f0";
      ctx.textAlign = "center";
      ctx.font = "32px sans-serif";
      ctx.fillText("YOU WIN!", canvas.width / 2, canvas.height / 2);

      ctx.font = "16px sans-serif";
      if (lastWonLevel === 1 && unlockedLevels >= 2) {
        ctx.fillText("Level 2 unlocked!", canvas.width / 2, canvas.height / 2 + 30);
      }
    }

    function loop(now) {
      if (gameState === "menu") {
        updateMenu();
        drawMenu();
      } else if (gameState === "level1" || gameState === "level2") {
        updateLevel();
        drawLevel();
      } else if (gameState === "win") {
        updateWin(now);
        drawWin();
      }

      requestAnimationFrame(loop);
    }

    requestAnimationFrame(loop);
  </script>
</body>
</html>
